12.08.2002
==========

* Working on APACIC::Hard_Interface
  - nomenclature:
	removed "using namespace" in .H file
	changed variables names to the convention
	removed unneeded #include
  - NLL Cluster

* Temporary Change in MOCAIC::Mocaic
  - inserted abort() after me_ps_interface call

13.08.2002
==========

* Working on APACIC::Hard_Interface
    - created NEW class Combine_Table.H and .C for easy winnergraph determination
	
* Temporary switched off "Z" boson in MOCAIC-Particle.dat
	
* Changed (again) AMEGIC::Topology::Copy and AMEGIC::Topology::Build_Single
	in order to generate topologies with correct prevs
* inserted operator<< for easy "Point"-tree output 

14.08.2002
==========

* Working on APACIC::Hard_Interface
    - extensive tests (debuging) of Combine_Table for Process
	"e+ e- -> b bbar gluon gluon" (Model QCD)

* Temporary Change in MOCAIC::Mocaic
  - inserted Rambo initialisiation

15.08.2002
==========

* Working on APACIC::Hard_Interface
    - generalised Combine_Table::CombineLegs for initial state
    - new test process  "c b  -> c b gluon gluon" (Model pure QCD)  
	(38 Graphs  -  including initial states)
    - inserted comments in code and introduced simplification

* Working on APACIC::Interface_Tools (start filling showers)
    - removed using namespace in .H file
    - new Methods:
	Point2Knot()
	FillTrees()

* RK removed Bug in String_Generator.C
    - Simplify() killed!
	

16.08.2002
==========
* Working on APACIC::Interface_Tools 
    - Debugging of 
	FillTrees()
    - Test FillTrees with 2, 3 and 4 Jets
	"e+ e- -> b bbar gluon  gluon" (Model QCD)     OK!  (8 Graphs)
	"e+ e- -> b bbar b bbar" (Model QCD)           OK!  (8 Graphs)
	"e+ e- -> b bbar c cbar" (Model QCD)           OK!  (4 Graphs)
	"e+ e- -> b bbar gluon" (Model QCD)            OK!  (2 Graphs)
	"e+ e- -> b bbar" (Model QCD)                  OK!  (1 Graph)
	"e- b  -> e- b gluon gluon" (Model QCD)             (8 Graphs)
       prinzipiell OK, aber hohe warscheinlichkeit fuer "e- e- cluster".
	"b  c  ->  b  c  gluon gluon" (Model  pure QCD) OK (36 Graphs !!)

  ISR cluster muss Warscheinlichkeit ein solches teilchen im BEAM 
  zufinden einbeziehen!!!

	
19.08.2002
==========

* Working on APACIC::Combine_Table
     - add momenta propagation   ...done
     - "subtract" for isr points!!! ...done

* Working on Interface_Tools
     - make mother momenta for final state tree ...done
     - set status und info, and check ini structure (left <-> right)
	                                        ...partial done !?
     - check momentum conservation ini+fin
           =>  GetMomentum()

20.08.2002
==========
	
* Working on 2 -> 2 Process_Library
     - in order to extract color structure
     - added initialisation of Process_Selector in Mocaic.C 
	(added psel=0 in destructor of Mocaic and Hard_Processes, to avoid
	double delete)
     - make a Process_Group in Hard_Interface (Should probably be moved to
	Hard_Interactions)
     - minor change in Process_Base and Process_Group
	added First() and Next() and changed reference selected to
	iterator selected
     - Added SetColours(double s, double t,double u) in XS_Base and
	Process_Base and all corresponding QCD Processes
	unneccessary SetColour declarations have been removed.
     - BUG: - removed shadowing declarations
	 in XS_q1q1_q1q1::Differential 
	 in XS_q1qbar1_q1qbar1::Differential
	 in XS_q1qbar1_gg::Differential
	 in XS_gg_q1qbar1::Differential
	 in XS_q1g_q1g::Differential
	 in XS_gg_gg::Differential

21.08.2002
==========
 * Working on Interface_Tools
     - Set and Propagate Colors
     - BUG: always the same tree -> Reset Trees in Testroutine in Mocaic.C
     - BUG: e+ is massive (about 1 GeV)!
     - BUG: gluon off still enables gluon in graphs!!!
	   -> in Model_QCD.C inserted "if ison()"
     - Test Color assignment - OK
     - BUG: in Final_State_Shower::InitializeJets
	   -> added return in else branch.
     - Test :  e+e- -> d dbar         .. OK
	       e+e- -> d dbar g       .. Kinematics fails!!
	       e+e- -> d dbar g g     .. seems to work?!

22.08.2002
==========
 * Working on Interface_Tools, Final_State_Shower, Timelike_Kinematics, etc.

      - slightly extending Comments in Headerfiles
      - removed unneeded AMATOOLS:: in .C files
      - removed using namespace in Spacelike_Kinematics.H

26.08.2002
==========
 * Working on InitialzeJets and Co.
      - Problem:  old InitializeJets only works, if both branches have
	daughters, i.e. for 2 Jets and 4 Jets (Starform)
      - Solution: Mass of branch without daughters has to be known before
	Initialising the branch with daughters,
        momenta (of both branches and all daughters) have to be
	"Shuffled"
      - made rearrangements in 
		Final_State_Shower::InitializeJets()
		Timelike_Kinematics::KinCheck()
	using existing structure of
		Final_State_Shower::FillBranch()
		Final_State_Shower::EvolveJets()
		Timelike_Kinematics::ShuffleMoms()
      - does not work jet!!!
      - looking more closely at 	
		Timelike_Kinematics::ShuffleMoms()
	BUG: for already massive momenta
		ShuffleMoms() and DoKinematics() doesn't work correctly!
      -	new treatment for already massive momenta in
		Timelike_Kinematics::ShuffleMoms()
        BUG: intermediate momenta from FillTrees wrong, resolved below.
      - changing Tree.C and Tree.H to make easy Boost of branches possible
      - boost/rotatate daughters when mass of aunt has changed
	 => problem daugthers are ignored, when ME kinematic has to be restored!
      -	restored original structure of InitializeJets (possible since
	kinematics has been addapted)
      - change Timelike_Kinematics::DoKinematics()
	  make momenta only when not yet set
	  "boost rot" daughters (note rot only neccessary if jet>4)
      - BUGs: (0828b)
	  - resets knot 2 to t=0 even though it should be diced down
            further from "472 GeV^2		
	  - InitializeJets FillBranch trys to evolve already filled branch
	    after first try failed!!!! Which should never happen!
	  - and even fails to recreate ME kinematics => DoKinematics
  	    doesn't work properly!!!!
	  * this corresponds probably to begin from the beginning once
	    again (the famous "10%" in pythia). No, it doesn't since this
	    should only happen in ISR Shower
	Changes
	  replaced Reset in EvolveJet by ResetDaughters -> didn't work as expected!
	TODO:
	  - if evolution of the only free branch fails, reshuffle moms a
  	    last time and exit (i.e. do not try to evolve the fixed
	    branch!)  ... OK!
          - check if Reset() is (in general) called at the right times!
	        What is if FillBranch always return true, even if no
	        daughters have been found ?! 
	    testing:
	       + introduced new knot stat==3 ( boot => int)
	       + redice knot if daughters didn't work out
	       + Change struckture, that always both daughters are evolved
	         even if already the first fails.
                5,9,8,7,4,3,14,6,6,7
		8,7,7,11,10, 16,17,13,7,21
	
	  - check if all partons on their t_out!
	
 * Working on Combine_Table and Co
      - introduce more comments
      - removed small bug in mom determination found above 
      - introduce "rpa.gen.Debugging()" statements before outputs

02.09.2002
==========
 * general
      - removed CXX=g++ statements in APACIC, ATOOLS, PDF, MOCAIC, Analysis
      - removed using namespace in .H files from  ATOOLS, PHASIC, AMEGIC, APACIC, MOCAIC,
      - transfered class Message back in Message.H
      - corrected Picobarn() in Run_Parameter.H
      - removed cout statements in APACIC::Shower, APACIC::Hard_Interface,
	 APACIC::Soft_Interface
 * Working on NLL_Sudakov.H
      - removed using namespace
      - introduced Kabbala Methodes (for easier checks)
      - Interface_Tools 
	  initialise NLL_Sudakov
          knots, and last_scale/last_iscale should be inserted for "j"   ?!
	            ... done, doesn't change any thing ! think about it once more!
      - check wether first argument of GetLeg(.,.) is correct ?!
	introduced GetLeg with on method only

      - adapted fastfunc to our nomenclatur -> Fast_Function
      - introduced Gauss_Integrator in AMATOOLS

      - generate sudakovs, and compare with old sudakovs .....
	
      - Set scales in NLL_Sudakov
          tmin -> Q_min = sqrt(tmin)
          tmax -> Q_max = sqrt(tmin)

      - Compare with APACIC 1.1 
	  * "ll-as"
	       setscale = 1/2*Ecms ! => as(Mz)=0.118587  statt parameter.dat value
               - as(Mz) fixed auf 0.118 in nll.C
	       - asmue=as(mue=Mz/2) in first order determined
	       - as is only 0th order using asmue
	       - remaining difference of about 10^-5
	  * "G_q" and "G_g_G_f" (with K-factor)
	       - remaining difference of about 10^-5
	  * Delta_q and Delta_g 
	       - agreement to at least 10^4
	  * changes
	      mue=Mz
	      as(Mz) = parameter.dat value
	... OK

     - AlphaS-factors	
     - Changes in Kabbala.H created Kabbala.C (cf. Makefile.am)
	 added ostream operator<<
	added operator*= for a "double"
	

09.09.2002
==========
*new "ostream" for fast "no output"
      -	NoStream stream, with empty operator<<() methods;
      - ordinary ostream operators<< are no longer called when NoStream is
	used.                                             GOOD
      - Function Calls in Stream are still performed.     NOT GOOD
      - does n't work, if "down casted to ostream" and more
	than one operator<<() in one line                 BAD
      - Segguestion: create generic stream for both output, and no_output!

* color connections -> start angle
      - general methode implemented:
      - e+ e- -> d dbar g g              ....works
      - e+ e- -> d dbar photon 	         ....dosn't
	BUG: internal flavour=anti-flavour (but does not hold for Shower!)
	=> check charge conservation!
      - QCD Processes not jet defined ask frank
* solved BUG: e+ is (sometimes) massive (about 1 GeV) (cf. 21.08.02)
      - added "&" in GetFlavs in Process.H

* change in Combine_Table.C .H, Interface_Tools.C .H, Hard_Interface.C .H
      -	change Point* to "Leg"
      -	charge is now only meaning full in combination with "anti"!!!

* changes in Interface_Tools.C
      -	tout set to sqr(mass())    in Interface_Tools::Point2Knot()
      - removed tmin==1. statement in Interface_Tools::FillTrees()
      - disabled 0&1 clustering	Combine_Table::FillTable()

* changed shower initialiation vars
      - start scale and thcrit have to be determined according to the
	Suddakovs!

17.09.2002
==========	
      - stategy to deal with "minimum of N jets"
          determine Sudakovs acording short write.tex
      - write mathematica programs
	  * determine coefficients of jetrates 
	        and sudakovs
	  * evaluate generating functionals to
	       obtain jetrates
	  * determine analytic integral of 
	       sudakove exponen

01.10.2002
==========
=> Continue working on MOCAIC/APACIC
* changed shower initialiation vars
      - start scale and thcrit have to be determined according to the
	Suddakovs!
      -	e+e- => 2,3,4,5 Jet                works OK!
      - c b  => c b gluon gluon    seems to work (ISR conditions not complete!)

* changed final state shower, evolve free branch first!
      -	Final_State_Shower::InitializeJets   (change order)
      - Timelike_Kinematics::KinCheck	     (only recursive if not jet	set!)
      -	Interface_Tools::Point2Knot          (status initialisation->3)	
	
* Problem (1001a) : e+e- => d dbar u ubar    TODO!!!!
      -	initial state clustering possible!!!!  (SM t-channels!!!)
      - initial state shower has atleast to start final state showers!!!
                                                       (check start conditions)
	  or
	force no clustering with initial particles!

      - maked "bottom base" shower: initialize first free legs and
	afterwards initialize fixed
      - solved Problem (1001a)

	

01.11.2002
==========
-> make plots : Diff - jetrates (Note: Ralf bereits in Cambridge getestet)
->   Data
->   LO
->   NLL (NJet, .GE.NJet) analytic/showers
->   LO x NLL (determine "kappas")
->   check showers
-> make	and test analytic Sudakov!

	
TODO:
      -	check shower initialisiation vars again
	(t_start,t_veto,t_end,max_angle,color-structure) 
        a  t_start has to be corresponding value in the sudakov!
	b  check high scale in sudakov (angular variable?!)
	c  angle has same restriction point as start scale, due to bad
 	   emulation of angular ordering, wich in turn is already garuantied
	   by y_cut.
      -	QCD_Processes
      -	me_library writing "vec4d -> APHYTOOLS:: ..." etc.
      - do only generate momenta above ycut!
      - check whether 4 quark event can get weights bigger than 1 (cf. Q.8.)

      - look for alphaS routine (apparently only leading order !?)
	
      -	Check Showers!!!
      -	Colour guess, falls kein Process-Match!
      -	what about boosts ?!!!
      -	check ISR cluster scheme (wichtig fuer PP!)
	  k_t sheme is without boost naive correct also for initial parton
	clustern. but different schemes for different initial state
	

 Question:
    1.)	Same cluster mechanism, can have different graphs
	with possibly different color structure, e.g.
	   e + e- -> u ubar d dbar (with gluon, photon, W+-).
	How to choose right one?! What is the meaning of it in 
	conection with color reconnection? Or should only
	strong graphs be possible in order to cancel the right 
	logs?! Some cluster mechnism have only weak graphs!

	My Guess:  Cluster and Sudakov weight only according to 
	strong graphs, but colors according to all graphs.
	In turn this means, that Combine_Table is some what over
	engineered, but still the more general and cleaner solution.

	strong graphs, all graphs with more then one electoweak boson

        F: coupl/prop determines whether gluon/photon/Z
	
    2.) Is it possible that ME kinematics does not match any PS kinematics
	due to different mass treatment (i guess hardly, since jet
	constrains have to be full filled).

    3.) "second chance"
	should a knots whose daughters didn't pass the extra jet veto
	not get a second chance to evolve down, instead to get fixed to	
	its mass shell?!
	And if so, should it be diced down from the begining, or from its
	failed mass?
	My Guess, dice further from the failed mass, since it is like 
	a "late"-failed kinecheck!

    4.) Why is kinecheck recursive? Shouldn't it be possible to check only
	direct neighbors? Cf. also  5. 
	Has to be cf. 3.

    5.) Is "first InitalizeJets (of fixed leg) and after that evolve the
	free leg" the right strategy? It appearently doesn't match the
	ordinary shower behavior. And the virtuality of the free leg
	becomes much more restricted! 
	.

    6.) Is tmin a constant or ymin?!! In the latter case we might have to
	deal with a two dimensional sudakov fast function, or we have
	definetely to include a analytic version.

	ymin is constant.
	tmin might change   (e+ e-) (photon photon)  sprime
             does not change                  (P P) s_hadron

    7.) What about negative branching probabilities (and) negative sudakov
	exponents?
	alphaS*delta/delta combination is smalle 1, should be sufficient.
	
    8.) Why a factor 5 when four outgoing quarks?
	Cluster possibilities are very constrained! Perhaps this leads to
	a gluon with increasing virtuality! And consequently a
	Sudakov-Weight > One.
	Seguesstions:
	 a)  constrain all single sudakovs to be small or equal to one.
	 b)  constrain all single fractions to be small than one
	        or
	     change upper and lower Q value, in case they are misordered.
	cf.7.)
	
	
    9.) Does the k_t-cluster scheme automatically work for initial state
	clustering? 
	Process dependence of K_t scheme!!!
	

   10.) Does the thcrit "Final_State_Shower.C" line 533+ work in case an
	intermediate photons is radiated.

============================================= answered !

	
   11.) Does the kind of veto influence the start value of the sudakov
	(for the next dice)?

   12.) Is there a way using a odering in y_ij rather than t_i or theta_ij?

   13.) What is the Bremsstrahlung scheme?


	
 Suggestions:
    1.) Insert generic color (flow) information into Flavour
	Write a universal "SetColor routine" used in FillTree and 
	in all Showers! (better Parton)

    2.) Think of a more complicated select-daugther scheme (to for
	instance increase the number of "hard" partons). E.g. don't
	neccessarily choose the more off-shell daughter, if a smaller 
	mass for their sister also comply with the kinematic constrains.
	Or, choose a daughter statistically according to there remaining
	sudakovs (including kinematic constrains) (my favorite).
	

    3.) Improve vec3d (and perhaps vec4d)
	  - include  costheta(vec?d, vec?d)
	  - include  sintheta(vec?d, vec?d)
	  - define static const momenta
	     null4d, null3d, xvec3d, yvec3d, zvec3d, tvec, xvec, yvec, zvec
	  - check "!=" and "==" operators

    4.) Improve Fast_Function,
	  - linear -> spline
	  - find routine -> hash table

Notes:

        Knot::stat      0  -  Toechter bereits bestimmt/nicht mehr wuerfelbar
         => act         1  -  noch zum wuerfeln frei
	                3  -  choose me for next dice!!!!
	
        Parton::status  2  -  decayed parton (entspricht stat==0)
                        1  -  final state parton
        Parton::info   'M' -  pseudo Mutter des Final State Parton Showers
                       'H' -  aus dem hartem Matrixelement
                       'f' -  im FS erzeugt und weiter zerfallen
                       'F' -  im FS erzeugtes Final State Parton
                       'G' -  ins harte Matrixelement einlaufendes Parton
                       'i' -  im Backward Shower erzeugtes Parton
                       'I' -  primaeres "Beam" parton
