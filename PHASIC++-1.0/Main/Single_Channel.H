#ifndef Single_Channel_H
#define Single_Channel_H

#include "Message.H"
#include "Cut_Data.H"
#include "Flavour.H"
#include "Vector.H"
#include "Info_Key.H"

namespace PHASIC {

  class Single_Channel {
  protected:

    ATOOLS::Flavour *fl;
    std::string      name;

    long int n_points, n_contrib;
    double   weight, result, result2;
    double   res1, res2, res3;
    double   alpha, alpha_save;

    int     nin, nout;
    double *ms;
    double  sprimerange[3], yrange[2], p_ylimits[2], m_weight;
    double  m_Q, sprime, y, y0, ymin, ymax, Eprime, E1, E2;

    int      rannum;
    double  *rans;

  public:

    // constructor
    Single_Channel();
    Single_Channel(Single_Channel *);
    Single_Channel(int,int,const ATOOLS::Flavour *);
    Single_Channel(int,int,const ATOOLS::Flavour *,ATOOLS::Integration_Info * const) {};

    // destructor
    virtual ~Single_Channel();

    virtual void AddPoint(double);
    void Reset(double value);
    void ResetOpt();

    virtual void Reset() {}

    virtual void GeneratePoint(ATOOLS::Vec4D *,ATOOLS::Cut_Data *,double *);
    virtual void GeneratePoint(ATOOLS::Vec4D *,ATOOLS::Cut_Data *);
    virtual void GenerateWeight(ATOOLS::Vec4D *,ATOOLS::Cut_Data *);

    virtual void GeneratePoint(ATOOLS::Vec4D *,double *); 
    virtual void GeneratePoint(ATOOLS::Vec4D *);
    virtual void GenerateWeight(ATOOLS::Vec4D *);

    virtual void GeneratePoint(double &,double &,int,double *);
    virtual void GeneratePoint(double &,double &,int);
    virtual void GenerateWeight(double,double,int);

    virtual void GeneratePoint(ATOOLS::Info_Key &spkey,ATOOLS::Info_Key &ykey,
			       const double *rans,const int mode=0);
    virtual void GeneratePoint(ATOOLS::Info_Key &spkey,ATOOLS::Info_Key &ykey,
			       const int mode=0);
    virtual void GenerateWeight(const int mode=0);

    virtual void CalculateLimits(ATOOLS::Info_Key &spkey,ATOOLS::Info_Key &ykey);
    virtual void CalculateLimits();

    virtual void SetRange(double * _sprimerange,double * _yrange);
    virtual void GetRange(); 
    virtual void ISRInfo(int &,double &,double &); 
    virtual int  ChNumber(); 
    virtual void SetChNumber(int);

    virtual ATOOLS::Flavour *Flavs(); 
    virtual std::string      Name();     
    virtual std::string      ChID();
    virtual size_t           Dimension() const;

    virtual int N();
    virtual int ValidN();
    virtual int Nin();    
    virtual int Nout();  

    virtual double Res1();  
    virtual double Res2();  
    virtual double Res3();  
    virtual double Weight();
    virtual double Alpha(); 
    virtual double AlphaSave();
    virtual double Result();   

    virtual void IncrementN();               
    virtual void SetRes1(double r);         
    virtual void SetRes2(double r);         
    virtual void SetRes3(double r);         
    virtual void SetN(long int n);          
    virtual void SetName(std::string name); 
    virtual void SetWeight(double weight);  
    virtual void SetAlpha(double alpha);    
    virtual void SetAlphaSave(double alpha);

    virtual void Optimize();
    virtual void EndOptimize();
    virtual void WriteOut(std::string);
    virtual void ReadIn(std::string);
  };// end of class Single_Channel

  /*! 
    \enum chr::type
    \brief declares the mode for setting phase space integration channel ranges
  */
  
  /*!
    This class is the mother class for all channels that
    are constructed depending on the process.
  */
  /*!
    Some basic ingredients for all channels :
    numbers of legs, their flavours and masses squared (not needed for isr)
    and the name of the channel. This name might be given explicitly 
    (for instance for ISR_Channels) or it may be constructed from amplitudes 
    in the Phase_Space/Channel_Generator.
  */
  /*!
    Stuff for the immediate integration 
  */
  /*!
    Specifics for isr and beamchannels
  */
  /*!
    Explicit constructor. 
    It initializes outgoing masses and the vector of random numbers :
    For them the following construction is applied :
    - two rans for the first pair of outgoing particles (orientation)
    - three rans for each new particle, one for the intermediate propagator,
      two for the orientation of the splitting
  */
  /*!
    Adding a value to the Single_Channel. It basically increments n,
    eventuall n_contrib, and the various result, result2, and res{i} in
    appropriate manners.
  */
  /*!
    Resetting the channels completely for a new integration.
  */
  /*!
    Resetting for the optimization involves a bit more. However, the accumulated
    results are kept. So this involves only what was accumulated between two iteration
    steps for the optimzation procedure. See the Multi_Channel for more information.
  */
  /*!
    Point and weight generation for fsr channels.
  */
  /*!
    Point and weight generation for isr channels.
  */

}

#endif




