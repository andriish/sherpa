#include "Primitive_Analysis.H"
#include "Analysis_Object.H"
#include "Message.H"
#include "MyStrStream.H"
#include "Shell_Tools.H"

#ifdef PROFILE__Analysis_Phase
#include "prof.hh"
#else 
#define PROFILE_HERE {}
#define PROFILE_LOCAL(LOCALNAME) {}
#endif

using namespace ANALYSIS;
using namespace ATOOLS;

Primitive_Analysis::Primitive_Analysis(const std::string _name, const int mode) :
  m_active(true)
{
  m_nevt = 0;
  p_partner = this;
  m_mode = mode;

  m_name = std::string("Analysis : ") + _name;
  msg_Tracking()<<" Initializing Primitive_Analysis : "<<m_name<<std::endl;
}

Primitive_Analysis::Primitive_Analysis(const int mode) :
  m_nevt(0), p_partner(this), m_active(true)
{
  m_mode = mode;

  m_name = std::string("Analysis : noname");
  msg_Tracking()<<" Initializing Primitive_Analysis : "<<m_name<<std::endl;
}

Primitive_Analysis::~Primitive_Analysis()
{
  for(int i=m_objects.size();i>0;i--) {
    if (m_objects[i-1]) delete m_objects[i-1];
  }
  m_objects.clear();

  for (Analysis_List::iterator it=m_subanalyses.begin();it!=m_subanalyses.end();++it) 
    delete it->second;
  m_subanalyses.clear();
}

void Primitive_Analysis::AddObject(Analysis_Object * obs) 
{
  obs->SetAnalysis(p_partner);
  std::string oname=obs->Name();
  std::string id="_A";
  size_t pos=oname.find(".dat");
  for(size_t i=0;i<m_objects.size();++i) {
    if (m_objects[i]->Name()==obs->Name()) {
      std::string pname;
      if (pos!=std::string::npos)
	pname=oname.substr(0,pos)+id+oname.substr(pos);
      else 
	pname=oname+id;
      obs->SetName(pname);
      ++id[1];
    }
  }
  m_objects.push_back(obs);
}

void Primitive_Analysis::AddSubAnalysis(const std::string & key,Primitive_Analysis * ana)
{
  Analysis_List::const_iterator cit=m_subanalyses.find(key);
  if (cit!=m_subanalyses.end()) {
    msg_Out()<<"WARNING in Primitive_Analysis::AddSubAnalysis :"<<std::endl
	     <<"   Analysis "<<key<<" already existent;"<<std::endl
	     <<" sub analysis not added, will be deleted."<<std::endl;
    if (ana) delete ana;
    return;
  }

  m_subanalyses[key]=ana;  
}

Primitive_Analysis * Primitive_Analysis::GetSubAnalysis(const std::string & key, int mode) 
{
  Analysis_List::const_iterator cit=m_subanalyses.find(key);
  if (cit!=m_subanalyses.end()) return cit->second;

  bool master=true;
  if (key=="ME" || key=="MI" || key=="Shower" || key=="Hadron") {
    master=false;
    if (key!="ME"     && mode&ANALYSIS::do_me) mode=mode^ANALYSIS::do_me;
    if (key!="MI"     && mode&ANALYSIS::do_mi) mode=mode^ANALYSIS::do_mi;
    if (key!="Shower" && mode&ANALYSIS::do_shower) mode=mode^ANALYSIS::do_shower;
    if (key!="Hadron" && mode&ANALYSIS::do_hadron) mode=mode^ANALYSIS::do_hadron;
  }

  Primitive_Analysis * ana = new Primitive_Analysis(m_name.substr(11)+key,mode);
  if (master) ana->SetPartner(p_partner);

  for (size_t i=0;i<m_objects.size();i++) {
    if (m_objects[i]->IsObservable() || !master) 
      ana->AddObject(m_objects[i]->GetCopy());
  }
  m_subanalyses[key]=ana;
  return ana;
}

std::string Primitive_Analysis::JetID
(std::string name,std::string max) const
{
  size_t jets(1), maxjets(100);
  std::string subprocs;
  if (max.length()>0) {
    size_t pos(max.find('['));
    if (pos!=std::string::npos) {
      maxjets=ToType<int>(max.substr(0,pos));
      max=max.substr(pos);
    }
    else {
      maxjets=ToType<int>(max);
      max="";
    }
  }
  for (size_t i(0);i<name.length();++i) {
    if (name[i]=='_' && name[i-1]=='_') ++jets;
    else if (name[i]=='[') {
      std::string cmax;
      for (size_t j(0);j<max.length();++j) {
	if (max[j]=='[') {
	  int open(1);
	  for (size_t k(j+1);k<max.length();++k) {
	    if (max[k]=='[') ++open;
	    if (max[k]==']') --open;
	    if (open==0) {
	      cmax=max.substr(j+1,k-j-1);
	      max=max.substr(k+1);
	      break;
	    }
	  }
	}
      }
      int open(1);
      for (size_t j(i+1);j<name.length();++j) {
	if (name[j]=='[') ++open;
	if (name[j]==']') --open;
	if (open==0) {
	  if (jets>1) subprocs+=ToString(jets-1);
	  subprocs+="["+JetID(name.substr(i+1,j-i-1),cmax)+"]";
	  jets=0;
	  i=j;
	  break;
	}
      }
    }
  }
  if (maxjets<jets) return "X";
  return subprocs+ToString(jets);
}

void Primitive_Analysis::CallSubAnalysis(const Blob_List * const bl, double value) 
{
  int nout=-1;
  std::string name, pname;
  for (Blob_List::const_iterator bit=bl->begin();bit!=bl->end();++bit) {
    if ((*bit)->Type()==btp::Signal_Process) {
      nout  = (*bit)->NOutP();      
      pname=name=(*bit)->TypeSpec();
      size_t bpos(name.find('{'));
      if (bpos!=std::string::npos) {
	pname=name.substr(bpos+1,name.find('}')-bpos-1);
	name=name.substr(0,bpos);
      }
      break;
    }
  }
  if (nout==-1) {
    msg_Out()<<"WARNING in Primitive_Analysis::CallSubAnalysis: no Signal process found "<<std::endl;
    return;
  }

  Blob_Data_Base * extra_info=operator[]("OrderEWeak");

  std::string key;
  int mode;
  if (extra_info && m_mode&ANALYSIS::splitt_extra) {
    mode=m_mode^ANALYSIS::splitt_extra;
    if (m_mode&ANALYSIS::splitt_jetseeds)
      mode=m_mode^ANALYSIS::splitt_jetseeds;
    mode=mode|ANALYSIS::output_this;

    double dkey=extra_info->Get<double>();
    key="extra_"+ATOOLS::ToString(dkey);

    GetSubAnalysis(key,mode);

    for (Analysis_List::iterator it=m_subanalyses.begin();it!=m_subanalyses.end();++it) {
      if (it->first.find("extra_")!=std::string::npos) {
	if (it->first==key) {
	  it->second->DoAnalysis(bl,value);
	}
	else {
	  m_active=false;
	  it->second->DoAnalysis(bl,value);
	  m_active=true;
	}
      }
    }
  }
  if (m_mode&ANALYSIS::splitt_jetseeds) {
    mode=m_mode^ANALYSIS::splitt_jetseeds;
    if (mode&ANALYSIS::splitt_extra)
      mode=m_mode^ANALYSIS::splitt_extra;
    mode=mode|ANALYSIS::output_this;
    std::string fsname(pname.substr(pname.find("__")+3));
    fsname=fsname.substr(fsname.find("__")+3);
    fsname=fsname.substr(fsname.find("__")+3);
    key=JetID(fsname,m_maxjettag);
    if (name!=pname && m_maxjettag!="") {
      bool maxn(key.find('X')!=std::string::npos);
      size_t cur(ToType<int>(key)), nmax(ToType<int>(m_maxjettag));
      for (size_t i(0);i<=nmax;++i) {
	if (i!=cur || maxn) {
	  Primitive_Analysis * ana=GetSubAnalysis("j"+ToString(i),mode);
	  ana->DoAnalysis(bl,0.0);
	}
      }
      if (!maxn) {
	Primitive_Analysis * ana=GetSubAnalysis("jX",mode);
	ana->DoAnalysis(bl,0.0);
      }
    }
    key="j"+key;
  }
  else {
    mode=m_mode^ANALYSIS::splitt_process;
//     if (m_mode&ANALYSIS::output_process) mode=mode|ANALYSIS::output_this;
//     else 
    if (m_mode&ANALYSIS::output_this) mode=mode^ANALYSIS::output_this;
      key=name;
  }
  if (key.find('X')!=std::string::npos) {
    msg_Debugging()<<METHOD<<"(): Max jet number reached in '"<<key<<"'\n";
  }

  Primitive_Analysis * ana=GetSubAnalysis(key,mode);
  ana->DoAnalysis(bl,value);
}


void Primitive_Analysis::DoAnalysis(const Blob_List * const bl, const double value) {
  ++m_nevt;

  if (m_mode&ANALYSIS::splitt_phase) {
    m_mode=m_mode|ANALYSIS::output_this;
    int mode=m_mode^ANALYSIS::splitt_phase;
    if (m_mode&ANALYSIS::do_me)     GetSubAnalysis("ME",mode)->DoAnalysis(bl,value);
    if (m_mode&ANALYSIS::do_mi)     GetSubAnalysis("MI",mode)->DoAnalysis(bl,value);
    if (m_mode&ANALYSIS::do_shower) GetSubAnalysis("Shower",mode)->DoAnalysis(bl,value);
    if (m_mode&ANALYSIS::do_hadron) GetSubAnalysis("Hadron",mode)->DoAnalysis(bl,value);
    return;
  }

  ClearAllData();
  p_blobs = bl;

  // if (value!=1.) m_mode=m_mode|ANALYSIS::weighted;
  if (p_partner==this) {
    m_mode=m_mode|ANALYSIS::fill_helper;
    m_mode=m_mode|ANALYSIS::output_this;
  }
  else if (m_mode&ANALYSIS::fill_helper) m_mode=m_mode^ANALYSIS::fill_helper;
  if (p_partner==this &&  m_mode&ANALYSIS::weighted) {
    m_mode= m_mode|ANALYSIS::splitt_process;
  }
  else if (m_mode&ANALYSIS::splitt_process) {
    m_mode=m_mode|ANALYSIS::output_process;
  }
  if ((m_mode&ANALYSIS::splitt_all)==0) m_mode=m_mode|ANALYSIS::fill_histos;
  if (m_mode&ANALYSIS::weighted && m_mode&ANALYSIS::splitt_all) {
    m_mode=m_mode^(m_mode&ANALYSIS::fill_histos);
  }
  Init();
  double weight=(*p_partner)["ME_Weight"]->Get<double>();
  double procweight=1.;
  if (m_mode&ANALYSIS::weighted_ns || 
      !(m_mode&ANALYSIS::weighted)) {
    Blob_Data_Base *info((*p_partner)["Process_Weight"]);
    if (info!=NULL) procweight=info->Get<double>();
  }
  weight/=procweight;
  int    ncount=(*p_partner)["ME_NumberOfTrials"]->Get<int>();
  if (!IsEqual(value/procweight,weight)) {
    if (p_partner==this) {
      msg_Out()<<"WARNING in Primitive_Analysis::DoAnalysis :"<<std::endl
	       <<"   Weight in Primitive_Analysis ambiguous! ("<<value/procweight<<","<<weight<<")"<<std::endl;
    }
    else if (value/procweight==0.) {
      weight=0.;
    }
    else {
      msg_Out()<<"WARNING something is wrong in Primitive_Analysis::DoAnalysis :"<<std::endl
	       <<"   Weight in Primitive_Analysis ambiguous! ("<<value/procweight<<","<<weight<<")"<<std::endl;
    }
  }
  double weight_one=weight;
  int    ncount_one=ncount;
  Blob_Data_Base * info = (*p_partner)["ME_Weight_One"];
  if (info) {
    weight_one = info->Get<double>();
    weight_one/= procweight;
    ncount_one = (*p_partner)["ME_NumberOfTrials_One"]->Get<int>();
  }
  if (weight==0.) weight_one=0.;
  m_stats.sum_weight     += weight;
  m_stats.nevt           += ncount;
  m_stats.sum_weight_one += weight_one;
  m_stats.nevt_one       += ncount_one;
  
  // do nonsplittable (helper and legacy objects) first
  if (m_mode&ANALYSIS::fill_helper) {
    for (size_t i=0;i<m_objects.size();i++) {
      if (!m_objects[i]->IsObservable()) {
	m_objects[i]->Evaluate(*bl,value/procweight,ncount);
      }
    }
  }

  if (m_mode&ANALYSIS::fill_histos) {
    for (size_t i=0;i<m_objects.size();i++) {
      if (m_objects[i]->IsObservable()) {
	m_objects[i]->Evaluate(*bl,value/procweight,ncount);
      }
    }
  }


  if (m_mode&ANALYSIS::splitt_all) CallSubAnalysis(bl,value);
  if (p_partner==this && msg_LevelIsTracking()) PrintStatus();

  ClearAllData();
}

void Primitive_Analysis::FinishAnalysis(const std::string & resdir,long ntotal, double xs) 
{
  if (ntotal==0) ntotal=m_nevt;
  if (m_mode&ANALYSIS::output_this) 
    ATOOLS::MakeDir(resdir+OutputPath()); 

  for (Analysis_List::iterator it=m_subanalyses.begin();
       it!=m_subanalyses.end();++it) {
    std::string dir=resdir+OutputPath()+std::string("/")+it->first;
    it->second->FinishAnalysis(dir,ntotal,xs);
  }

  if (!(m_mode&ANALYSIS::splitt_phase)) {
    for (size_t i=0;i<m_objects.size();i++) {
      if (m_mode&ANALYSIS::weighted  && m_mode&ANALYSIS::splitt_all && 
	  m_objects[i]->IsObservable()) {
	std::string key = m_objects[i]->Name();
	m_objects[i]->Reset();  // just in case someone has filled something in already
      
	for (Analysis_List::iterator it=m_subanalyses.begin();
	     it!=m_subanalyses.end();++it) {
	  if (it->first.find("extra_")==std::string::npos) {
	    Analysis_Object * ob = it->second->GetObject(key);
	    if (ob)   (*m_objects[i])+=(*ob);
	  }
	}
      }
      else {
	if (m_mode&ANALYSIS::weighted_ns) {
	  m_objects[i]->EndEvaluation(double(m_stats.nevt)/double(ntotal)*xs);
	}
	else {
	  if ((m_mode&ANALYSIS::weighted)==0 ) {
	    m_objects[i]->EndEvaluation(double(m_nevt)/double(ntotal)*xs);
	  }
	  else {
	    if (m_stats.nevt_one>0 && m_stats.sum_weight!=0.) {
	      double xshist=m_stats.sum_weight/double(m_stats.nevt);
	      double xsreal=m_stats.sum_weight_one/double(m_stats.nevt_one);
	      m_objects[i]->EndEvaluation(xsreal/xshist);
	    }
	    else {
	      m_objects[i]->EndEvaluation();
	    }
	  }
	}
      }
      if (m_mode&ANALYSIS::output_this) 
	m_objects[i]->Output(resdir+OutputPath());
    }
  }
}

void Primitive_Analysis::Init()
{
  if (m_mode&ANALYSIS::fill_helper)
    CreateFinalStateParticleList();
}

bool Primitive_Analysis::SelectBlob(const ATOOLS::Blob *blob) 
{
  if (m_mode&ANALYSIS::do_hadron) return true;
  if (m_mode&ANALYSIS::do_shower && 
      (blob->Type()==btp::IS_Shower || blob->Type()==btp::FS_Shower ||
       blob->Type()==btp::Shower)) return true;
  if (m_mode&ANALYSIS::do_mi && 
      (blob->Type()==btp::Hard_Collision ||
       blob->Type()==btp::Signal_Process)) return true;
  if (m_mode&ANALYSIS::do_me && blob->Type()==btp::Signal_Process) return true;
  return false;
}

void Primitive_Analysis::CreateFinalStateParticleList()
{
  PL_Container::const_iterator cit=m_pls.find(finalstate_list);
  if (cit!=m_pls.end()) return;

  Particle_List * pl = new Particle_List;

  for (Blob_List::const_iterator blit=p_blobs->begin();
       blit!=p_blobs->end();++blit) {
    if ((*blit)->Type()==btp::Signal_Process) {
      Blob_Data_Base * info=(*(*blit))["ME_Weight"];
      if (info) {
	m_datacontainer["ME_Weight"]=new Blob_Data<double>(info->Get<double>());
	info=(*(*blit))["Process_Weight"];
	if (info) {
	  m_datacontainer["Process_Weight"]=new Blob_Data<double>(info->Get<double>());
	}
	info=(*(*blit))["XS_Weight"];
	if (info) {
	  m_datacontainer["XS_Weight"]=new Blob_Data<double>(info->Get<double>());
	}
	info=(*(*blit))["Sud_Weight"];
	if (info) {
	  m_datacontainer["Sud_Weight"]=new Blob_Data<double>(info->Get<double>());
	}
	info=(*(*blit))["XS_NumberOfTrials"];
	if (info) {
	  m_datacontainer["XS_NumberOfTrials"]=new Blob_Data<int>(info->Get<int>());
	}
	info=(*(*blit))["ME_NumberOfTrials"];
	if (info) {
	  m_datacontainer["ME_NumberOfTrials"]=new Blob_Data<int>(info->Get<int>());
	}
      }
      info=(*(*blit))["ME_Weight_One"];
      if (info) {
	m_datacontainer["ME_Weight_One"]=new Blob_Data<double>(info->Get<double>());
	info=(*(*blit))["ME_NumberOfTrials_One"];
	if (info) {
	  m_datacontainer["ME_NumberOfTrials_One"]=new Blob_Data<int>(info->Get<int>());
	}
      }
    }
    if ((*blit)->Type()==ATOOLS::btp::ME_PS_Interface_FS) {
      Blob_Data_Base * info=(*(*blit))["OrderStrong"];
      if (info &&m_datacontainer.find("OrderStrong")==m_datacontainer.end()) {
	m_datacontainer["OrderStrong"]=new Blob_Data<double>(info->Get<double>());
	info=(*(*blit))["OrderEWeak"];
	if (info) {
	  m_datacontainer["OrderEWeak"]=new Blob_Data<double>(info->Get<double>());
	}
      }
    }
    for (String_BlobDataBase_Map::const_iterator it=(*blit)->GetData().begin();
	   it!=(*blit)->GetData().end(); ++it) {
      if (it->first.length()>2 && it->first[0]=='d' && it->first[1]=='#') {
	m_datacontainer[it->first.substr(2)]=new Blob_Data<double>(it->second->Get<double>());
	m_datacontainer["NULL"+it->first.substr(2)]=new Blob_Data<double>(0.);
      }
    }

    if (SelectBlob(*blit)) {
      for (int i=0;i<(*blit)->NOutP();++i) {
	Particle * p = (*blit)->OutParticle(i);
	if (p->DecayBlob()==NULL || 
	    (m_mode&ANALYSIS::do_hadron)==0 && p->Info()!='G') {
	  if ((p->Info()!='G' &&  p->Info()!='H')
	      || (*blit)->Type()!=btp::IS_Shower) {
	    pl->push_back(p);
	  }
	}
      }
    }
  }

  bool found=false;
  if (m_datacontainer.find("ME_Weight")!=m_datacontainer.end()) found=true;
  if (!found) {
    m_datacontainer["ME_Weight"]=new Blob_Data<double>(1.);
    m_datacontainer["ME_NumberOfTrials"]=new Blob_Data<int>(1);
    m_datacontainer["ME_Weight_One"]=new Blob_Data<double>(0.);
    m_datacontainer["ME_NumberOfTrials_One"]=new Blob_Data<int>(0);
  }
  else if (!m_datacontainer["ME_NumberOfTrials"]) {
    m_datacontainer["ME_NumberOfTrials"]=new Blob_Data<int>(1);
    m_datacontainer["ME_Weight_One"]=new Blob_Data<double>(0.);
    m_datacontainer["ME_NumberOfTrials_One"]=new Blob_Data<int>(0);
  }
  m_pls[finalstate_list]=pl;
  AddParticleList("NULL",new Particle_List);
}

Particle_List * Primitive_Analysis::GetParticleList(const std::string & key,
						    const bool nocreate) 
{
  if (!m_active) {
    PL_Container::const_iterator cit=m_pls.find("NULL");
    if (cit!=m_pls.end()) return cit->second;
  }
  PL_Container::const_iterator cit=m_pls.find(key);
  if (cit!=m_pls.end()) return cit->second;
  if (nocreate) return NULL;
  if (key==finalstate_list) CreateFinalStateParticleList();
  cit=m_pls.find(key);
  if (cit!=m_pls.end()) return cit->second;
  msg_Error()<<METHOD<<"(): List '"<<key<<"' not found."<<std::endl;
  return NULL;
}

void Primitive_Analysis::AddParticleList(const std::string & key,Particle_List * pl) 
{
  PL_Container::const_iterator cit=m_pls.find(key);
  if (cit!=m_pls.end()) {
    for (Particle_List::iterator pit=cit->second->begin(); 
	 pit!=cit->second->end();++pit) 
      if ((*pit)->ProductionBlob()==NULL && (*pit)->DecayBlob()==NULL) delete *pit;
    delete cit->second;
  }

  m_pls[key]=pl;
}

ATOOLS::Blob_Data_Base * Primitive_Analysis::operator[](const std::string name) 
{
  ATOOLS::String_BlobDataBase_Map::const_iterator cit;
  if (!m_active) {
    cit=m_datacontainer.find("NULL"+name);
    if (cit!=m_datacontainer.end()) return cit->second;
  }
  cit=m_datacontainer.find(name);
  if (cit==m_datacontainer.end()) return 0;
  return cit->second;
} 

void Primitive_Analysis::AddData(const std::string name, Blob_Data_Base * data) 
{
  String_BlobDataBase_Map::iterator it=m_datacontainer.find(name);
  if (it==m_datacontainer.end()) {
    m_datacontainer[name]=data;
  }
  else {
    delete it->second;
    it->second=data;
  }
}

void Primitive_Analysis::ClearAllData() 
{
  for (PL_Container::iterator it=m_pls.begin();
       it!=m_pls.end(); ++it) {
    if (!it->second->empty()) {
      for (Particle_List::iterator pit=it->second->begin(); 
      	   pit!=it->second->end();++pit) 
      if ((*pit)->ProductionBlob()==NULL && (*pit)->DecayBlob()==NULL) 
	delete *pit;
    }
    delete it->second;
  }
  m_pls.clear();

  for (String_BlobDataBase_Map::iterator it=m_datacontainer.begin();
       it!=m_datacontainer.end(); ++it) delete it->second;
  m_datacontainer.clear();
}

void Primitive_Analysis::PrintStatus() 
{

  msg_Out()<<"Particle_Lists:"<<std::endl;
  for (PL_Container::iterator it=m_pls.begin();
       it!=m_pls.end(); ++it) {
    msg_Out()<<"   * "<<it->first<<" ("<<it->second->size()<<")"<<std::endl;
  }
  for (PL_Container::iterator it=m_pls.begin();
       it!=m_pls.end(); ++it) {
    msg_Out()<<"   * "<<it->first<<std::endl<<*it->second<<std::endl;
  }

  msg_Out()<<"Data_Container:"<<std::endl;
  for (String_BlobDataBase_Map::iterator it=m_datacontainer.begin();
       it!=m_datacontainer.end(); ++it) {
    msg_Out()<<"   * "<<it->first<<" ("<<*(it->second)<<")"<<std::endl;
  }
}

void Primitive_Analysis::SetPartner(Primitive_Analysis * const ana)
{
  p_partner=ana;
}

Analysis_Object * Primitive_Analysis::GetObject(const std::string & key)
{
  for (size_t i=0;i<m_objects.size();i++) {
    if (m_objects[i]->Name()==key) return m_objects[i];
  }
  return 0;
}

void Primitive_Analysis::Test(const int mode) 
{
  std::cout<<"Number of objects: "<<m_objects.size()<<std::endl;
  for (size_t i=0;i<m_objects.size();i++) {
    if (!m_objects[i]->IsObservable()) m_objects[i]->Test(mode);
  }
  for (size_t i=0;i<m_objects.size();i++) {
    if (m_objects[i]->IsObservable()) m_objects[i]->Test(mode);
  }
}

namespace ATOOLS {

template <>
std::ostream & Blob_Data<std::vector<double> *>::operator>>(std::ostream & s) const 
{
  if (m_data->size()>0) 
    s<<(*m_data)[0];
  for (size_t i=1;i<m_data->size();++i) 
    s<<","<<(*m_data)[i];
  return s;
}

template <> Blob_Data<std::vector<double> *>::~Blob_Data() 
{
  delete m_data;
}

template class Blob_Data<std::vector<double> *>;

}
