#include <iostream> 
#include "Run_Parameter.H"
#include "MathTools.H"
#include "Message.H"
#include "Exception.H"
#include "Random.H"
#include "Data_Reader.H"
#include "Data_Collector.H"
#include "MyStrStream.H"
#include "Shell_Tools.H"
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>
#include <pwd.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/sysctl.h>

size_t getpmem()
{
#if defined(ARCH_LINUX) || defined(ARCH_UNIX)
  return sysconf(_SC_PHYS_PAGES)*getpagesize();
#endif
#ifdef ARCH_DARWIN
  int mib[2]={CTL_HW,HW_PHYSMEM};
  unsigned int miblen(2);
  size_t pmem(0), len(sizeof(pmem));
  if (sysctl(mib,miblen,&pmem,&len,NULL,0)!=0) {
    std::cerr<<"sysctl failed"<<std::endl;
    return 0;
  }
  return pmem;
#endif
  std::cerr<<"cannot determine physical memory"<<std::endl;
  return std::numeric_limits<size_t>::max();
}

using namespace ATOOLS;

bool ATOOLS::Run_Parameter::s_initialized=false;
std::map<std::string,std::string> ATOOLS::Run_Parameter::s_variables;
Run_Parameter ATOOLS::rpa;

Run_Parameter::Run_Parameter() 
{
  AnalyseEnvironment();
  gen.m_output    = gen.m_analysis   = 0;
  gen.m_nevents   = 0;
  gen.m_cutscheme = 0;
  gen.m_ecms      = gen.m_accu        = 0.;
  gen.m_beam1     = gen.m_beam2      = Flavour(kf_none);
#ifndef USING__ATOOLS_only
  gen.p_model     = NULL;
#endif
  gen.m_ndicedevents = 0;
  gen.m_batchmode = 1;
  gen.SetTimeOut(3600);
  gen.SetWAnaScale(1.);
  gen.m_spincorrelations = 0;
} 

std::ostream &ATOOLS::operator<<(std::ostream &str,const Run_Parameter &rp)
{ 
  return str<<"("<<&rp<<"): {\n}"; 
}

void Run_Parameter::AnalyseEnvironment() 
{
  if (s_initialized) return;
#ifdef __GNUC__
#if __GNUC__ == 2 && __GNUC_MINOR__ == 96
#error Sherpa was not designed for gcc 2.96
#endif
#endif
  std::string gccv;
  FILE *pout(popen("gcc -dumpversion","r"));
  int cch;
  while ((cch=fgetc(pout))!=EOF) gccv+=(char)cch;
  pclose(pout);
  if (gccv.find('\n')!=std::string::npos) 
    gccv=gccv.substr(0,gccv.find('\n'));
  if (gccv.find("2.96")!=std::string::npos) {
    THROW(fatal_error,"Sherpa must not be run on gcc version 2.96 !");
  }
  char *var=NULL;
  s_variables["PATH"]=std::string(((var=getenv("PATH"))==NULL?"":var));
  s_variables["SHERPASYS"]=std::string(((var=getenv("SHERPASYS"))==NULL?"":var));
  s_variables["SHERPA_PDF_PATH"]=std::string(((var=getenv("SHERPA_PDF_PATH"))==NULL?"":var));
  s_variables["SHERPA_CPP_PATH"]=std::string(((var=getenv("SHERPA_CPP_PATH"))==NULL?"":var));
  s_variables["SHERPA_LIB_PATH"]=std::string(((var=getenv("SHERPA_LIB_PATH"))==NULL?"":var));
  s_variables["SHERPA_DAT_PATH"]=std::string(((var=getenv("SHERPA_DAT_PATH"))==NULL?"":var));
  s_variables["LD_LIBRARY_PATH"]=std::string(((var=getenv("LD_LIBRARY_PATH"))==NULL?"":var));
  s_variables["SHERPA_BIN_PATH"]=SHERPA_BINARY_PATH;
  s_variables["SHERPA_RUN_PATH"]=getenv("PWD");
  s_variables["HOME"]=std::string(((var=getenv("HOME"))==
				   NULL?s_variables["SHERPA_RUN_PATH"]:var));
  s_initialized=true;
}

void Run_Parameter::Init(std::string path,std::string file,int argc,char* argv[])
{
  m_path = path;
  path=s_variables["PATH_PIECE"];
  gen.m_timer.Start();
  struct passwd* user_info = getpwuid(getuid());
  if (!user_info) gen.m_username="<unknown user>";
  else gen.m_username=user_info->pw_gecos;
  Data_Read dr(m_path+file);
  Switch::code color=dr.GetValue<Switch::code>("PRETTY_PRINT",Switch::On);
  if (color==Switch::On) {
    termios testos;
    if (tcgetattr(STDOUT_FILENO,&testos)==0) msg->SetModifiable(true);
  }
  if (dr.ErrorCode()>0) 
    THROW(missing_input,"Main steering file not found. Stop.");
  gen.m_output = dr.GetValue<int>("OUTPUT",0);
  std::string logfile=dr.GetValue<std::string>("LOG_FILE",std::string(""));
  msg->Init(gen.m_output,logfile);
  if (msg->Level()>0) 
    msg_Out()<<"Welcome to Sherpa, "<<gen.m_username
	     <<". Initialization of framework underway."<<std::endl;
  // make path nice
  if (path.length()>0) {
    if (path[0]!='/') path=s_variables["SHERPA_RUN_PATH"]+"/"+path;
    while (path.length()>0 && 
	   path[path.length()-1]=='/' || path[path.length()-1]=='.') 
      path=path.substr(0,path.length()-1);
  }
  // set pdf path
  std::string pdfpath=dr.GetValue<std::string>("SHERPA_PDF_PATH",std::string(""));
  if (pdfpath.length()>0 && pdfpath[0]=='/') s_variables["SHERPA_PDF_PATH"]=pdfpath;
  else if (s_variables["SHERPA_PDF_PATH"].length()==0) 
    s_variables["SHERPA_PDF_PATH"]=SHERPA_SHARE_PATH;
  s_variables["SHERPA_SHARE_PATH"]=SHERPA_SHARE_PATH;
  // set cpp path
  std::string cpppath=dr.GetValue<std::string>("SHERPA_CPP_PATH",std::string(""));
  if (cpppath.length()>0 && cpppath[0]=='/') s_variables["SHERPA_CPP_PATH"]=cpppath;
  else if (path!=s_variables["SHERPA_RUN_PATH"]) s_variables["SHERPA_CPP_PATH"]=path;
  else if (s_variables["SHERPA_CPP_PATH"].length()==0) 
    s_variables["SHERPA_CPP_PATH"]=s_variables["SHERPA_RUN_PATH"];
  // set lib path
  std::string libpath=dr.GetValue<std::string>("SHERPA_LIB_PATH",std::string(""));
  if (libpath.length()>0 && libpath[0]=='/') s_variables["SHERPA_LIB_PATH"]=libpath;
  else if (s_variables["SHERPA_LIB_PATH"].length()==0) 
    s_variables["SHERPA_LIB_PATH"]=s_variables["SHERPA_CPP_PATH"]
      +std::string("/Process/lib");
  s_variables["SHERPA_INC_PATH"]=SHERPA_INCLUDE_PATH;
  if (s_variables["SHERPA_DAT_PATH"].length()==0)
    if (path.length()>0 && path[0]=='/') s_variables["SHERPA_DAT_PATH"]=path;
    else s_variables["SHERPA_DAT_PATH"]=s_variables["SHERPA_RUN_PATH"]+"/"+path;
  msg_Tracking()<<METHOD<<"(): Paths are {\n"
		<<"   SHERPA_BIN_PATH = "<<s_variables["SHERPA_BIN_PATH"]<<"\n"
		<<"   SHERPA_INC_PATH = "<<s_variables["SHERPA_INC_PATH"]<<"\n"
		<<"   SHERPA_PDF_PATH = "<<s_variables["SHERPA_PDF_PATH"]<<"\n"
		<<"   SHERPA_CPP_PATH = "<<s_variables["SHERPA_CPP_PATH"]<<"\n"
		<<"   SHERPA_LIB_PATH = "<<s_variables["SHERPA_LIB_PATH"]<<"\n"
		<<"   SHERPA_DAT_PATH = "<<s_variables["SHERPA_DAT_PATH"]<<"\n"
		<<"}"<<std::endl;
#ifndef __sgi
  setenv("LD_LIBRARY_PATH",(s_variables["LD_LIBRARY_PATH"]+std::string(":")+
			    s_variables["SHERPA_LIB_PATH"]).c_str(),1);
#endif
  MakeDir(s_variables["HOME"]+"/.sherpa/",true);
  gen.m_analysis           = dr.GetValue<int>("ANALYSIS",0);
  gen.m_nevents            = dr.GetValue<long>("EVENTS",100);
  // read only if defined (no error message if not defined)

  Data_Reader dreader(" ",";","!","=");
  dreader.AddWordSeparator("\t");
  dreader.SetInputFile(m_path+file);
  std::vector<long int> seeds;
  gen.m_seed2 = -1;
  if (dreader.VectorFromFile(seeds,"RANDOM_SEED")) {
    gen.m_seed = seeds[0];
    // if 2nd seed is given, store it
    if (seeds.size() == 2) { gen.m_seed2 = seeds[1]; } 
  } else gen.m_seed=1234;

  gen.m_timeout            = dr.GetValue<double>("TIMEOUT");
  if (gen.m_timeout<0.) gen.m_timeout=0.;
  rpa.gen.m_timer.Start();
  gen.m_batchmode          = dr.GetValue<int>("BATCH_MODE");
  if (gen.m_batchmode==NotDefined<int>()) gen.m_batchmode=1;
#ifdef RLIMIT_AS
  rlimit lims;
  getrlimit(RLIMIT_AS,&lims);
  long int slim(getpmem());
  msg_Tracking()<<METHOD<<"(): Getting memory limit "
		<<slim/double(1<<30)<<" GB."<<std::endl;
  std::vector<std::string> aspars;
  if (!dreader.VectorFromFile(aspars,"RLIMIT_AS")) {
    lims.rlim_cur=(rlim_t)(slim-100*(1<<20));
  }
  else {
    if (aspars.size()==1) {
      lims.rlim_cur=(rlim_t)
	(ToType<double>(aspars[0])*double(slim));
    }
    else if (aspars.size()==2) {
      if (aspars[1]=="MB") lims.rlim_cur=(rlim_t)
	(ToType<double>(aspars[0])*(1<<20));
      else if (aspars[1]=="GB") lims.rlim_cur=(rlim_t)
	(ToType<double>(aspars[0])*(1<<30));
      else if (aspars[1]=="%") lims.rlim_cur=(rlim_t)
	(ToType<double>(aspars[0])*double(slim/100.0));
      else
	THROW(fatal_error,"Invalid syntax in '"+m_file+"'");
    }
    else {
      THROW(fatal_error,"Invalid syntax in '"+m_file+"'");
    }
  }
  if (setrlimit(RLIMIT_AS,&lims)!=0)
    msg_Error()<<METHOD<<"(): Cannot set memory limit."<<std::endl;
  getrlimit(RLIMIT_AS,&lims);
  msg_Info()<<METHOD<<"(): Setting memory limit to "
	    <<lims.rlim_cur/double(1<<30)<<" GB."<<std::endl;
#endif
  int stacktrace           = dr.GetValue<int>("STACK_TRACE");
  if (stacktrace==NotDefined<int>()) stacktrace=1;
  exh->SetStackTrace(stacktrace);
  std::string ycut=dr.GetValue<std::string>("YCUT");
  if (ycut!=NotDefined<std::string>()) gen.SetVariable("Y_CUT",ycut);
  gen.m_accu = dr.GetValue<double>
    ("Num._Accuracy",dr.GetValue<double>("NUM_ACCURACY",1.e-10));
  //gen.m_runtime            = dr.GetValue<std::string>("Runtime"); // Time
  if (gen.m_seed2!=-1) { ran.SetSeed(gen.m_seed, gen.m_seed2); }
                  else { ran.SetSeed(gen.m_seed); }
  gen.m_ren_scale_fac=1.0;
  gen.m_fac_scale_fac=1.0;
  gen.m_pdf_scalefac=dr.GetValue<double>("PDF_SCALE_FACTOR",1.0);
  gen.m_as_scalefac=dr.GetValue<double>("AS_SCALE_FACTOR",1.0);
  if(gen.m_pdf_scalefac!=1.0 || gen.m_as_scalefac!=1.0) {
    PRINT_INFO("Attention: Operator approach for scale variations activated.  mu_f="
	       <<gen.m_pdf_scalefac<<";  mu_r="<<gen.m_as_scalefac);
  }
  msg_Debugging()<<METHOD<<"(): Set global tags {\n";
  const String_Map &gtags(Read_Write_Base::GlobalTags());
  for (String_Map::const_iterator tit(gtags.begin());tit!=gtags.end();++tit)
    msg_Debugging()<<"  '"<<tit->first<<"' -> '"<<tit->second<<"'\n";
  msg_Debugging()<<"}\n";
}

Run_Parameter::~Run_Parameter() 
{ 
  if (msg->Level()>=1) gen.m_timer.PrintTime();
}

bool Run_Parameter::Gen::CheckTime(const double limit)
{ 
  if (limit==0.) {
    if (m_timeout>0.) return m_timer.UserTime()<m_timeout;
  }
  else {
    return m_timer.UserTime()<limit;
  }
  return false;
}

void  Run_Parameter::Gen::SetEcms(double _ecms)     { 
  m_ecms    = _ecms;
  Data_Collector::AddData("ECMS",new Blob_Data<double>(m_ecms));
}
void  Run_Parameter::Gen::SetPBeam(short unsigned int i,Vec4D pbeam) { 
  m_pbeam[i]=pbeam;
  //  Data_Collector::AddData("PBEAM"+ToString(i),new Blob_Data<Vec4D>(m_pbeam[i]));
}
void  Run_Parameter::Gen::SetBeam1(const Flavour b) { 
  m_beam1  = b;   
  Data_Collector::AddData("BEAM1",new Blob_Data<std::string>(m_beam1.TexName()));
}
void  Run_Parameter::Gen::SetBeam2(const Flavour b) { 
  m_beam2  = b;   
  Data_Collector::AddData("BEAM2",new Blob_Data<std::string>(m_beam2.TexName()));
}

std::string Run_Parameter::Gen::Variable(const std::string &key,const std::string &def) 
{ 
  return s_variables.find(key)!=s_variables.end()?s_variables[key]:def; 
}
