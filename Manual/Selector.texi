@node Selectors
@section Selectors
@cindex SHOW_SELECTOR_SYNTAX

The setup of cuts at the matrix element level is covered
by the `(selector)' section of the steering file or the 
selector data file `Selector.dat', respectively.

Sherpa provides the following selectors

@menu
* Inclusive selectors::       inclusive particle selectors
* One particle selectors::    one particle selectors
* Two particle selectors::    two particle selectors
* Decay selectors::           decay selectors
* Particle dressers::         charged particle photon recombinations
* Jet selectors::             jet algorithms
* Universal selector::        user-defined cuts
* Minimum selector::          cuts that are inclusive for several selectors
@end menu

Some selectors modify the momenta and flavours of the set of 
final state particles. These selectors also take a list of 
subselectors which then act on the modified flavours and momenta. 
Details are explained in the respective selectors' description.

@node Inclusive selectors
@subsection Inclusive selectors

The selectors listed here implement cuts on the
matrix element level, based on event properties.
The corresponding syntax in @file{Selector.dat} is 
@verbatim
<keyword> [<parameters>] <min value> <max value>
@end verbatim

@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a form that is understood
by the internal algebra interpreter, see @ref{Interpreter}.
The selectors act on @emph{all} particles in the event. 
Their respective keywords are

@table @option
@item N <kf> <min value> <max value>
Minimum and maximum multiplicity of flavour @code{<kf>} in the 
final state.
@item PTmis <min value> <max value>
Missing transverse momentum cut (at the moment only neutrinos are 
considered invisible)
@item ETmis <min value> <max value>
Missing transverse energy cut (at the moment only neutrinos are 
considered invisible)
@item IsolationCut <kf> <dR> <exponent> <epsilon>
Smooth cone isolation @mycite{Frixione1998jh}, the parameters given 
are the flavour @code{<kf>} to be isolated against massless partons 
and the isolation cone parameters.
@item NJ <N> <algo> <min value> <max value>
NJettiness from @mycite{Stewart2010tn}, where @code{<algo>} specifies 
the jet finding algorithm to determine the hard jet directions and 
@code{<N>} is their multiplicity. 
@code{algo=kt|antikt|cambridge|siscone,PT:<ptmin>,R:<dR>[,[ETA:<etamax>,Y:<ymax>]]}
@end table

@node One particle selectors
@subsection One particle selectors

The selectors listed here implement cuts on the
matrix element level, based on single particle kinematics.
The corresponding  syntax in @file{Selector.dat} is 
@verbatim
<keyword> <flavour code> <min value> <max value>
@end verbatim

@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a form that is understood
by the internal algebra interpreter, see @ref{Interpreter}.
The selectors act on @emph{all} possible particles with 
the given flavour. Their respective keywords are

@table @option
@item PT
transverse momentum cut
@item ET
transverse energy cut
@item Y
rapidity cut
@item Eta
pseudorapidity cut
@item PZIN
cut on the z-component of the momentum, acts on initial-state flavours only
(commonly used in DIS analyses)
@end table


@node Two particle selectors
@subsection Two particle selectors

The selectors listed here implement cuts on the
matrix element level, based on two particle kinematics.
The corresponding  syntax in @file{Selector.dat} is 
@verbatim
<keyword> <flavour1 code> <flavour2 code> <min value> <max value>
@end verbatim

@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a form that is understood
by the internal algebra interpreter, see @ref{Interpreter}.
The selectors act on @emph{all} possible particles with 
the given flavour. Their respective keywords are

@table @option
@item Mass
invariant mass
@item Q2
DIS-like virtuality
@item PT2
pair transverse momentum
@item MT2
pair transverse mass
@item DY
rapidity separation
@item DEta
pseudorapidity separation
@item DPhi
azimuthal separation
@item DR
angular separation (build from eta and phi)
@item DR(y)
angular separation (build from y and phi)
@item INEL
inelasticity, one of the flavours must be in the initial-state (commonly used
in DIS analyses)
@end table


@node Decay selectors
@subsection Decay selectors

The selectors listed here implement cuts on the matrix element level, 
based on particle decays, see @ref{Decay} and @ref{DecayOS}.
 
@table @option
@item DecayMass
Invariant mass of a decaying particle. The syntax is
@verbatim
DecayMass <flavour code> <min value> <max value>
@end verbatim
@item Decay
Any kinematic variable of a decaying particle. The syntax is
@verbatim
Decay(<expression>) <flavour code> <min value> <max value>
@end verbatim
where @code{<expression>} is an expression handled by the
internal interpreter, see @ref{Interpreter}. 
@item Decay2
Any kinematic variable of a pair of decaying particles. The syntax is
@verbatim
  Decay2(<expression>) <flavour1 code> <flavour2 code> <min value> <max value>
@end verbatim
where @code{<expression>} is an expression handled by the
internal interpreter, see @ref{Interpreter}. 
@end table
Particles are identified by flavour, i.e. the cut is applied 
on @emph{all} decaying particles that match @option{<flavour code>}.
@option{<min value>} and @option{<max value>} are floating point
numbers, which can also be given in a format that is understood
by the internal algebra interpreter, see @ref{Interpreter}.


@node Particle dressers
@subsection Particle dressers

@node Jet selectors
@subsection Jet selectors

There are three different types of jet finders

@table @option
@item JetFinder   
k_T-algorithm
@item ConeFinder  
cone-algorithm
@item NJetFinder
k_T-type algorithm to select on a given number of jets
@end table

Their respective syntax is 
@verbatim
JetFinder  <ycut>[<ycut decay 1>[<ycut decay 11>...]...]... <D parameter>
ConeFinder <min R> 
NJetFinder <n> <ptmin> <etmin> <D parameter> [<exponent>] [<eta max>] [<mass max>]
FastjetFinder <algorithm> <n> <ptmin> <etmin> <dr> [<f(siscone)>=0.75] [<eta-max>] [<y-max>] [<nb>] [<nb2>]
@end verbatim

For @option{JetFinder}, it is possible to give different values
of ycut in individual subprocesses of a production-decay chain.
The square brackets are then used to denote the decays.
In case only one uniform set of ycut is to be used, the square brackets
are left out.

@option{<ycut>}, @option{<min R>} and @option{<D parameter>} are
floating point numbers, which can also be given in a form that is
understood by the internal algebra interpreter, see @ref{Interpreter}.

The @option{NJetFinder} allows to select for kinematic configurations with
at least @option{<n>} jets that satisfy both, the @option{<ptmin>} and
the @option{<etmin>} minimum requirements and that are in a PseudoRapidity region
|eta|<@option{<eta max>}. The @option{<exponent>} allows to apply a kt-algorithm
(1) or an anti-kt algorithm (-1). As only massless partons are clustered by 
default, the @option{<mass max>} allows to also include partons with a mass 
up to the specified values. This is useful e.g. in calculations with massive 
b-quarks which shall nonetheless satisfy jet criteria.

The final option @option{FastjetFinder} allows to use the 
@uref{http://www.fastjet.fr,,FastJet} plugin if enabled during configuration. 
It takes the following mandatory arguments:
@code{<algorithm>} can take the values
@code{kt,antikt,cambridge,siscone,eecambridge,jade},
@code{<n>} is the minimum number of jets to be found, @code{<ptmin>} and 
@code{<etmin>} are the minimum transverse momentum and/or energy, 
@code{<dr>} is the radial parameter. Optional arguments are: 
@code{<f(siscone)>} (default 0.75), @code{<eta-max>} and @code{<y-max>} as 
maximal absolute (pseudo-)rapidity (default infinity),
@code{<nb>} and @code{<nb2>} set the number of required b-jets, where for the
former both b and anti-b quarks are counted equally towards b-jets, while for
the latter they are added with a relative sign as constituents, i.e. a jet
containing b and anti-b is not tagged.
Note that only @code{<algorithm>}, @code{<n>} and @code{<ptmin>} are relevant
for the lepton-lepton collider algorithms.

The option @option{FastjetVeto} allows to use the 
@uref{http://www.fastjet.fr,,FastJet} plugin to apply
jet veto cuts. The syntax is identical to option @option{FastjetFinder}.

If @uref{http://www.fastjet.fr,,FastJet} is enabled, the momenta and nodal 
values of the jets found with Fastjet can be used to calculate more elaborate 
selector criteria. The syntax of this selector is

@verbatim
FastjetSelector <expression> <algorithm> <n> <ptmin> <etmin> <dr> [<f(siscone)>=0.75] [<eta-max>] [<y-max>] [<bmode>]
@end verbatim

wherein @code{algorithm} can take the values
@code{kt,antikt,cambridge,siscone,eecambridge,jade}.
In the algebraic @code{expression} @code{MU_n2} (n=2..njet+1) signify the nodal 
values of the jets found and @code{p[i]} are their momenta. For details see
@ref{Scale setters}. For example, in lepton pair production in 
association with jets

@verbatim
FastjetSelector Mass(p[4]+p[5])>100. antikt 2 40. 0. 0.5
@end verbatim

selects all phase space points where two anti-kt jets with at least 40 GeV of
transverse momentum and an invariant mass of at least 100 GeV are found. The 
expression must calculate a boolean value.
The @code{bmode} parameter, if specified different from its default 0, allows
to use b-tagged jets only, based on the parton-level constituents of the jets.
There are two options: With @code{<bmode>=1} both b and anti-b quarks are
counted equally towards b-jets, while for @code{<bmode>=2} they are added with a
relative sign as constituents, i.e. a jet containing b and anti-b is not tagged.
Note that only @code{<epression>}, @code{<algorithm>}, @code{<n>} and
@code{<ptmin>} are relevant when using the lepton-lepton collider algorithms.

@node Universal selector
@subsection Universal selector
@cindex SHOW_VARIABLE_SYNTAX

The universal selector is intended to implement non-standard cuts
on the matrix element level. Its syntax is
@verbatim
"<variable>" <kf1>,..,<kfn> <min1>,<max1>:..:<minn>,<maxn> [<order1>,...,<orderm>]
@end verbatim

@emph{No additional white spaces are allowed}

The first word has to be double-quoted, and contains the name
of the variable to cut on. The keywords for available predefined
<variable>s can be figured by running Sherpa @option{SHOW_VARIABLE_SYNTAX=1}.
Or alternatively, an arbitrary cut variable can be constructed using
the internal interpreter, see @ref{Interpreter}. This is invoked
with the command @samp{Calc(...)}. In the formula specified there
you have to use place holders for the momenta of the particles: 
@samp{p[0]} ... @samp{p[n]} hold the momenta of the respective particles 
@samp{kf1} ... @samp{kfn}. A list of available vector functions and
operators can be found here @ref{Interpreter}.

@option{<kf1>,..,<kfn>} specify the PDG codes of the particles
the variable has to be calculated from. In case this choice is
not unique in the final state, you have to specify multiple cut ranges
(@option{<min1>,<max1>:..:<minn>,<maxn>}) for all (combinations
of) particles you want to cut on, separated by semicolons.

If no fourth argument is given, the order of cuts is determined
internally, according to Sherpa's process classification scheme.
This then has to be matched if you want to have different cuts
on certain different particles in the matrix element. To do this,
you should put enough (for the possible number of combinations 
of your particles) arbitrary ranges at first and run Sherpa 
with debugging output for the universal selector:
@samp{Sherpa OUTPUT=2[Variable_Selector::Trigger|15]}.
This will start to produce lots of output during integration,
at which point you can interrupt the run (Ctrl-c). In the
@samp{Variable_Selector::Trigger(): @{...@}} output you can see,
which particle combinations have been found and which cut range
your selector has held for them (vs. the arbitrary range you
specified). From that you should get an idea, in which order
the cuts have to be specified.

If the fourth argument is given, particles are ordered
before the cut is applied. Possible orderings are @option{PT_UP},
@option{ET_UP}, @option{E_UP}, @option{ETA_UP} and @option{ETA_DOWN},
(increasing p_T, E_T, E, eta, and decreasing eta). They have to be specified
for each of the particles, separated by commas.


Examples

@table @asis
@item Two-body transverse mass

      "mT" 11,-12 50,E_CMS

@item Cut on the pT of only the hardest lepton in the event

      "PT"   90   50.0,E_CMS   [PT_UP]

@item Using bool operations to restrict eta of the electron to |eta| < 1.1 or 1.5 < |eta| < 2.5

      "Calc(abs(Eta(p[0]))<1.1||(abs(Eta(p[0]))>1.5&&abs(Eta(p[0]))<2.5))" 11 1,1

      Note the range 1,1 meaning true for bool operations.

@item Requesting opposite side tag jets in VBF would for example need a setup like this

      "Calc(Eta(p[0])*Eta(p[1]))" 93,93 -100,0 [PT_UP,PT_UP]

@item Restricting electron+photon mass to be outside of [87.0,97.0]:

      "Calc(Mass(p[0]+p[1])<87.0||Mass(p[0]+p[1])>97.0)" 11,22 1,1

@item In @samp{Z[lepton lepton] Z[lepton lepton]}, cut on mass of lepton-pairs produced from Z's:

      "m"   90,90   80,100:0,E_CMS:0,E_CMS:0,E_CMS:0,E_CMS:80,100

      Here we use knowledge about the internal ordering to cut only on the correct lepton pairs.

@end table


@node Minimum selector
@subsection Minimum selector

This selector can combine several selectors to pass an event if either 
those passes the event. It is mainly designed to generate more inclusive 
samples that, for instance, include several jet finders and that allows 
a specification later. The syntax is

@verbatim
MinSelector {
  Selector 1
  Selector 2
  ...
} 
@end verbatim

The @ref{Minimum selector} can be used if constructed with other 
selectors mentioned in this section

