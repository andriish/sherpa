#ifndef Data_To_Function_IC
#define Data_To_Function_IC

#include "Data_To_Function.H"

using namespace ATOOLS;

namespace ATOOLS {

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::
  SetAcquisitionMode(AcquisitionModeID _m_acquisitionmode)
  { m_acquisitionmode = _m_acquisitionmode; }

  template <class Argument_Type,class Result_Type>
  inline typename Data_To_Function<Argument_Type,Result_Type>::AcquisitionModeID
  Data_To_Function<Argument_Type,Result_Type>::AcquisitionMode()
  { return m_acquisitionmode; }

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::
  SetInterpolationMode(InterpolationModeID _m_interpolationmode)
  { m_interpolationmode = _m_interpolationmode; }

  template <class Argument_Type,class Result_Type>
  inline typename Data_To_Function<Argument_Type,Result_Type>::InterpolationModeID 
  Data_To_Function<Argument_Type,Result_Type>::InterpolationMode()
  { return m_interpolationmode; }

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::
  Import(Data_To_Function<ArgumentType,ResultType> &reference)
  { Import(reference.p_xydata,reference.p_yxdata); }

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::Sort()
  { SortX(); SortY(); }

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::Resize(unsigned int newsize)
  {
    p_xydata->resize(newsize); 
    p_yxdata->resize(newsize); 
  }

  template <class Argument_Type,class Result_Type>
  bool Data_To_Function<Argument_Type,Result_Type>::AddPoint(Argument_Type x,Result_Type y)
  {
    ArgumentType _x=(*p_xaxis)(x);
    ResultType _y=(*p_yaxis)(y);
    if (p_xydata->size()!=0) {
      if (((*p_xydata)[ClosestX(_x)].first==_x)||
	  ((*p_yxdata)[ClosestY(_y)].second==_y)) return false;
    }
    p_xydata->push_back(XYPair(_x,_y)); 
    p_yxdata->push_back(YXPair(_y,_x));
    Sort();
    return true;
  }

  template <class Argument_Type,class Result_Type>
  inline Result_Type Data_To_Function<Argument_Type,Result_Type>::
  LinearY(ArgumentType x,unsigned int &left,unsigned int &right)
  { 
    ArgumentType xleft=(*p_xydata)[left].first, xright=(*p_xydata)[right].first;
    ResultType yleft=(*p_xydata)[left].second, yright=(*p_xydata)[right].second;
    return yleft+(x-xleft)*((yright-yleft)/(xright-xleft)); 
  }
  
  template <class Argument_Type,class Result_Type>
  inline Argument_Type Data_To_Function<Argument_Type,Result_Type>::
  LinearX(ResultType y,unsigned int &left,unsigned int &right)
  { 
    ResultType yleft=(*p_yxdata)[left].first, yright=(*p_yxdata)[right].first;
    ArgumentType xleft=(*p_yxdata)[left].second, xright=(*p_yxdata)[right].second;
    return xleft+(y-yleft)*((xright-xleft)/(yright-yleft)); 
  }
  
  template <class Argument_Type,class Result_Type>
  inline unsigned int Data_To_Function<Argument_Type,Result_Type>::ClosestX(ArgumentType x)
  {
    unsigned int dummyleft, dummyright;
    return ClosestX(x,dummyleft,dummyright);
  }

  template <class Argument_Type,class Result_Type>
  inline unsigned int Data_To_Function<Argument_Type,Result_Type>::ClosestY(ResultType y)
  {
    unsigned int dummyleft, dummyright;
    return ClosestY(y,dummyleft,dummyright);
  }

  template <class Argument_Type,class Result_Type>
  inline Result_Type Data_To_Function<Argument_Type,Result_Type>::DataY(ArgumentType x)
  { return (*p_xydata)[ClosestX(x)].second; }
  
  template <class Argument_Type,class Result_Type>
  inline Argument_Type Data_To_Function<Argument_Type,Result_Type>::DataX(ResultType y)
  { return (*p_yxdata)[ClosestY(y)].second; }

  template <class Argument_Type,class Result_Type>
  inline Result_Type Data_To_Function<Argument_Type,Result_Type>::operator()(ArgumentType x)
  { return Y(x,m_acquisitionmode); }
  
  template <class Argument_Type,class Result_Type>
  inline Argument_Type Data_To_Function<Argument_Type,Result_Type>::operator[](ResultType y)
  { return X(y,m_acquisitionmode); }

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::
  NormalizeY(ArgumentType xmin,ArgumentType xmax,ResultType norm)
  { 
    if (xmin==xmax) {
      xmin=(*p_xydata)[0].first;
      xmax=(*p_xydata)[p_xydata->size()-1].first;
    }
    ScaleY(norm/IntegrateY(xmin,xmax)); 
  }

  template <class Argument_Type,class Result_Type>
  inline void Data_To_Function<Argument_Type,Result_Type>::
  NormalizeX(ResultType ymin,ResultType ymax,ArgumentType norm)
  { 
    if (ymin==ymax) {
      ymin=(*p_yxdata)[0].first;
      ymax=(*p_yxdata)[p_yxdata->size()-1].first;
    }
    ScaleX(norm/IntegrateX(ymin,ymax)); 
  }

  template <class Argument_Type,class Result_Type>
  inline Argument_Type  Data_To_Function<Argument_Type,Result_Type>::XMin()
  { 
    if (p_xydata->size()>0) return (*p_xaxis)[(*p_xydata)[0].first]; 
    else return (ArgumentType)0.0; 
  }

  template <class Argument_Type,class Result_Type>
  inline Argument_Type  Data_To_Function<Argument_Type,Result_Type>::XMax()
  { 
    if (p_xydata->size()>0) return (*p_xaxis)[(*p_xydata)[p_xydata->size()-1].first]; 
    else return (ArgumentType)0.0; 
  }

  template <class Argument_Type,class Result_Type>
  inline Result_Type  Data_To_Function<Argument_Type,Result_Type>::YMin()
  { 
    if (p_yxdata->size()>0) return (*p_yaxis)[(*p_yxdata)[0].first]; 
    else return (ResultType)0.0; 
  }

  template <class Argument_Type,class Result_Type>
  inline Result_Type  Data_To_Function<Argument_Type,Result_Type>::YMax()
  { 
    if (p_yxdata->size()>0) return (*p_yaxis)[(*p_yxdata)[p_yxdata->size()-1].first]; 
    else return (ResultType)0.0; 
  }

  template <class Argument_Type,class Result_Type>
  inline int Data_To_Function<Argument_Type,Result_Type>::XPosition(ArgumentType x)
  { 
    int position=(int)ClosestX((*p_xaxis)(x)); 
    if ((*p_xydata)[position].first==(*p_xaxis)(x)) return position; 
    else return -1; 
  }

  template <class Argument_Type,class Result_Type>
  inline int Data_To_Function<Argument_Type,Result_Type>::YPosition(ResultType y)
  { 
    int position=(int)ClosestY((*p_yaxis)(y)); 
    if ((*p_yxdata)[position].first==(*p_yaxis)(y)) return position; 
    else return -1; 
  }

  template <class Argument_Type,class Result_Type>
  inline Argument_Type Data_To_Function<Argument_Type,Result_Type>::XData(unsigned int i)
  { return (*p_xaxis)[(*p_xydata)[i%p_xydata->size()].first]; }

  template <class Argument_Type,class Result_Type>
  inline Result_Type Data_To_Function<Argument_Type,Result_Type>::YData(unsigned int i)
  { return (*p_yaxis)[(*p_yxdata)[i%p_yxdata->size()].first]; }

  template <class Argument_Type,class Result_Type>
  inline unsigned int Data_To_Function<Argument_Type,Result_Type>::XDataSize()
  { return p_xydata->size(); }

  template <class Argument_Type,class Result_Type>
  inline unsigned int Data_To_Function<Argument_Type,Result_Type>::YDataSize()
  { return p_yxdata->size(); }

  template <class Argument_Type,class Result_Type>
  inline bool Data_To_Function<Argument_Type,Result_Type>::
  ReplaceXPoint(ArgumentType x,ResultType y)
  { bool success=DeleteXPoint(x); AddPoint(x,y); return success; }

  template <class Argument_Type,class Result_Type>
  inline bool Data_To_Function<Argument_Type,Result_Type>::
  ReplaceYPoint(ArgumentType x,ResultType y)
  { bool success=DeleteYPoint(y); AddPoint(x,y); return success; }

  template <class Argument_Type,class Result_Type>
  inline ATOOLS::Axis<Argument_Type> *Data_To_Function<Argument_Type,Result_Type>::XAxis()
  { return p_xaxis; }

  template <class Argument_Type,class Result_Type>
  inline ATOOLS::Axis<Result_Type> *Data_To_Function<Argument_Type,Result_Type>::YAxis()
  { return p_yaxis; }

  template <class Argument_Type,class Result_Type>
  inline Argument_Type Data_To_Function<Argument_Type,Result_Type>::DeltaXMax()
  { ResultType dummyleft, dummyright; return DeltaXMax(dummyleft,dummyright); }

  template <class Argument_Type,class Result_Type>
  inline Argument_Type Data_To_Function<Argument_Type,Result_Type>::DeltaXMin()
  { ResultType dummyleft, dummyright; return DeltaXMin(dummyleft,dummyright); }

  template <class Argument_Type,class Result_Type>
  inline Result_Type Data_To_Function<Argument_Type,Result_Type>::DeltaYMax()
  { ArgumentType dummyleft, dummyright; return DeltaYMax(dummyleft,dummyright); }

  template <class Argument_Type,class Result_Type>
  inline Result_Type Data_To_Function<Argument_Type,Result_Type>::DeltaYMin()
  { ArgumentType dummyleft, dummyright; return DeltaYMin(dummyleft,dummyright); }

} // end of namespace ATOOLS

#endif
